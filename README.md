# React + TypeScript + Vite
## 1. Настройка проекта
### 1.1. Запуск

`npm install --save-dev`
`npm run dev`
### 1.2. Работа с пакетами

В `dependencies` находятся зависимости, необходимые для запуска проекта. В `devDependencies` находятся зависимости, необходимые для разработки. 

Пакеты, необходимые для разработки, следует устанавливать через 
`npm install <package> --save-dev`. 
### 1.3. Версии

Версионирование проекта происходит с помощью поля `version` в файле package.json. Пока проект не отдан клиентам, его версия должна быть ниже 1.0.0.

**X.Y.Z**
1) X - номер мажорной версии. Существенные изменения, не совместимые с предыдущими версиями. 
2) Y - номер минорной версии. Изменения, совместимые с предыдущими версиями. Пример: новая небольшая функциональность
3) Z - номер патча. Незначительные изменения, совместимые с предыдущими версиями, как правило исправление ошибок
## 2. Разработка
### 2.1. Импорты

Во время разработки следует импортировать функции и другие вещи через абсолютные пути, чтобы не привязываться к слоям структуры проекта.

До каждого слоя есть свой абсолютный путь:
* **pages - @pages**
* **layouts - @layouts**
* **features - @features**
* **components - @components**
* **common - @common**
* **assets - @assets**

Пример импорта компонента в странице:
```ts
import Search from '@components/search/Search'
```

Абсолютные пути можно расширить, добавив нужный слой при необходимости. Для этого:
1) Зайти в tsconfig.app.json
2) Добавить новую запись в объекте **paths**: `"@name/*": ["name/*"]`, где вместо `name` указать название слоя. 
### 2.2. Архитектура проекта

Архитектура проекта описывается слоями и их взаимодействием:
1) **router** - маршрутизация. Здесь react отлавливает урлы приложения и подставляет соответствующие страницы
2) **pages** - страницы. Здесь содержатся все страницы приложения. Каждая страница представляет собой файл с экспортируемой функцией, возвращающей JSX код.
3) **features** - фичи или функциональности приложения. Здесь содержатся основные функции приложения, т.е. бизнес-логика. По сути, это те же компоненты, только более сложные. Часто фичу можно представить как смесь из нескольких компонент, объединяющую их в более сложную функциональную единицу. 
4) **components** - компоненты приложения. Это то, на чём строится приложение. Компоненты могут иметь свою внутреннюю логику исполнения. Компоненты должны иметь некоторый уровень абстракции, чтобы их можно было переиспользовать в нескольких местах.
5) **ui** - простейшие компоненты приложения, которые собираются в более сложные на верхних уровнях. По сути, данный слой представляет кирпичики, из которых собирается функциональность приложения. Здесь могут быть простые элементы интерфейса без бизнес логики.

Порядок использования строгий - сверху вниз (от п.1 до п.5). Так, слой components не может обращаться к слою features, а слой features не может обращаться к слою pages и т.д. Однако, хорошей практикой может быть перепрыгивать нижестоящие слои. Например, слой pages может обращаться к слою components, минуя features. 

### 2.3. Стиль написания кода

#### Стилизация

Название классов для стилизации пишем по БЭМ, за исключением отдельных классов для каждого блока и kebab кейса. Пример:

```jsx
<div className='styles.block'>
	<div className='styles.block__header'></div>
		<div className='styles.header__start'>
			<button className={`${styles.start__buttonManagement} ${props.disabled ? styles.start__buttonManagement_disabled : ''}`}></button>
		</div>
		<div className='styles.header__end'></div>
	<div className='styles.block__content'></div>
	<div className='styles.block__footer'></div>
</div>
```

1) Дочерний блок вначале названия имеет название блока родителя (пример: `block__header`)
2) Дочерний блок наследует только название родителя, без использования названий его родителей (пример: `header__start`, а не `block__header__start`)
3) Наименование стилей отдельных блоков в camelCase (пример: `start__buttonManagement`, а не `start__button-management`)
4) Использование модификаторов для блоков (пример: `start__buttonManagement` и `start__buttonManagement_disabled`, где второй - модификатор)

#### Типизация

Стараемся типизировать всё: константы, состояния, отдельные переменные, возвращаемое значение из функции.

(!) Типы именуются в `PascalCase`

Например, мы пишем `useState<boolean>(true)`, а не `useState(true)`. Таким образом, линтер во время билда/запуска сможет поругаться в случае, если вместо boolean значения мы передадим какое-то другое.

Кастомные типы мы всегда храним в одном из двух мест:
1) `lib/types.ts` - типы, которые используются только в текущем компоненте. Их не должен использовать никакой другой компонент. Пример: тип `ExpandVariant` в components/ui/button/lib/types.ts.
2) `common/types/<name>.ts` - общие типы, которые могут использоваться в нескольких местах приложения. `<name>`  - название, соответствующее предметной области, к которой относятся типы. Пример: тип `StationStatus` в common/types/stations.ts, который используется как в Dto, так и в разных компонентах для типизации.

`type Props` не относится к этому определению и лежит непосредственно в файле с компонентом.

#### Константы

(!) Константы, лежащие в `common/consts/` и `lib/consts`  именуются в `UPPER_SNAKE_CASE`
Константы, используемые в других местах (например внутри вашей функции) именуются в `camelCase`, как и обычные переменные.

Различные статические данные по возможности выделяйте в константы

Старайтесь избегать использования let/var и по возможности используйте const. Например, в следующем коде let можно и нужно изменить на const:
```jsx
let buttonVariant = props.variant

return (
	<button className={`${styles.button} ${styles[buttonVariant]}`}></button>
)
```

Общие константы мы храним в одном из двух мест:
1) `lib/consts.ts` - константы, которые используются только в текущем компоненте. Их не должен использовать никакой другой компонент. Пример: 
```js
const DEFAULT_BUTTON_STATE: ButtonState = {
	variant: 'default',
	active: false
}	
```
1) `common/consts/<name.ts>` - общие константы, которые могут использоваться в нескольких местах приложения. `<name>`  - название, соответствующее предметной области, к которой относятся константы. Пример: константа `CONNECTOR_STANDARDS` в common/consts/stations.ts, которая может использоваться на странице фильтров станций и на странице фильтров зарядных сессий.

#### Функции и кастомные хуки

Функции именуются в `camelCase`, за исключением функций, возвращающих JSX разметку (т.е. компонентов). Они именуются в `PascalCase`. 

Вам необходимо выделять функции, чтобы упростить читаемость кода и разграничить ответственность. А в некоторых случаях обеспечить переиспользуемость и соблюсти принцип DRY.

Все функции, не работающие с состоянием внутри компонента, следует выносить в другие файлы. Примером такой ф-ии может быть: форматирование строки, сортировка массива определённым образом, генератор чего-либо и т.д.

Функции, работающие с состоянием, как правило, должны быть простыми. То есть они легко читаются и являются достаточно краткими. Находятся они прямо в ф-ии компонента.

Функции, работающие с хуками, но не работающие с состоянием, мы также выносим как кастомные хуки.

И так, функции и хуки мы храним в одном из следующих мест:
1) `lib/functions.ts` - ф-ии, не работающие с состоянием компонента напрямую
2) `lib/hooks.ts` - хуки, которые в том числе могут работать с состоянием фичи/страницы через ReactContext (если такой присутствует)
3) `common/functions/<name>.ts` - общие функции, которые могут использоваться в нескольких компонентах
4) `common/hooks/<name>.ts` - общие хуки, которые могут использоваться в нескольких местах

**Теперь рассмотрим примеры**

Пусть есть функция, которая занимается преобразованием дня недели в формате числа к заданному формату:
```js
const convertWeekdayToReadableDay = (
	weekday: number
): ReadableDay | undefined => {
    switch (weekday) {
        case 1:
            return ReadableDays.MONDAY
        case 2:
            return ReadableDays.TUESDAY
        case 3:
            return ReadableDays.WEDNESDAY
        case 4:
            return ReadableDays.THURSDAY
        case 5:
            return ReadableDays.FRIDAY
        case 6:
            return ReadableDays.SATURDAY
        case 7:
            return ReadableDays.SUNDAY
        default:
            return undefined
    }
}
```
Данная ф-ия является общей и должна находиться в `common/functions/datetime.ts`

Рассмотрим следующую функцию:
```js
const getTimestampAsString = (t: Timestamp): string => {
    return `${t.day}.${t.month}.${t.year} ${t.hours}:${t.minutes}`
}
```
Она преобразует типизированное значение отметки даты и времени к строке в нужном формате. Эта ф-ия скорее всего является частной, поскольку в разных местах приложения отображаемый формат даты и времени может отличаться. Потому, она должна располагаться в `lib/functions.ts`

**О кастомных хуках**

Хук - это та же функция, но с некоторыми отличиями. Во-первых, хук именуется с ключевого слова `use`. Пример именования: `useStationFilters`. Хук работает с другими хуками, в этом и есть его смысл. Другими хуками могут быть как стандартные типа `useState`, `useNavigate`, `useContext`, так и другие кастомные. Хук возвращает объект.

Пример хука:
```js
const useStationLoader = (stationId: string) => {
	/* Кастомный хук, в котором находятся все запросы к бэку */
	const { getStationFromApi } = useApi()

	const [loading, setLoading] = useState<boolean>(true)
	const [error, setError] = useState<Error|undefined>()
	const [data, setData] = useState<Station|undefined>()

	/* Получение станции */
	const getStation = async (): Promise<Station> => {
		return getStationFromApi(stationId)
			.then(res => {
				/* Асинхронный запрос успешно отработал */
				if (res.error) setError(res.error)
				else if (res.station) setData(res.station)
			})
			/* Выполняется в любом случае */
			.finally(() => setLoading(false))
	}

	useEffect(() => {
		/* Выполняется единожды при загрузке компонента */
		getStation()
	}, [])

	return {
		data,
		/* Меняем название во избежание коллизий в компоненте */
		getStationError: error,
		stationLoading: loading
	}
}
```
Данный хук загружает данные по станции с бэкенда через хук `useApi` и предоставляет информацию о статусе загрузки и ошибке.

#### Использование данных в дереве компонентов

Для передачи данных в компоненты мы в первую очередь используем пропсы:

```js
type Props = {
	text: string
	onClick: () => void
	className?: string
}

function SomeComponent(props: Readonly<Props>): React.JSX.Element {...}
```

Таким образом, обращение к пропсам всегда идёт через `props` аргумент. Это позволяет отличить переменные внутри функции от пропсов. `Readonly` указывает на то, что аргумент props нельзя изменять.

Бывают ситуации, когда одни и те же данные могут передаваться в дереве компонентов на несколько слоёв. Рассмотрим следующий пример:
2) Страница `StationProfilePage` работает с запросами и получением данных. Запросы следующие: получение станции, оставление отзыва о коннекторе. Для оставления отзыва о коннекторе нам нужно из компонента `Connector` отловить событие клика. Пока мы просто используем Props и прокинем вниз функцию `onConnectorClick: (id: string) => void`
3) Фича `StationProfile` работает с компонентами, их отображением и состоянием. В фиче данные пробрасываются по нижестоящим компонентам. Что с функцией-обработчиком для оставления отзыва о коннекторе, которую мы ранее пробросили в Props? Пробрасываем её ниже - в компонент `Connector`. 
4) В компоненте `Connector` в features/StationProfile/components/connector мы используем функцию из Props так: `onClick={() => props.onConnectorClick(props.connector.id)}`

По итогу мы получили, что в фиче StationProfile у нас пропс, который только передаётся ниже и никак не используется. Таких слоёв может быть больше, так же, как и самих пропсов. Поэтому для такого используется **ReactContext**.

Все контексты храним в `src/contexts/`.

Вот пример типичного контекста:
```js
import { createContext } from 'react'

export const PageProxyContext = createContext<{
    onClick: (id: string) => void
    someVar: boolean
}>({
    onClick: _ => {},
    someVar: true
})
```

В скобках угловых стрелочек задаётся структура: перечисляются аргументы, которые будут использоваться. Внутри вторых скобок указываются значения по умолчанию.